# Базовый гайд по SystemVerilog
***
## Введение
Этот гайд предназначен для людей, уже знакомых с программированием, которые хотят освоить язык SystemVerilog и научиться программировать FPGA.

### Структура гайда
**Основы языка**
- Основы синтаксиса SystemVerilog.
- Написание базовых программ в симуляторе.
- Разработка проектов на симуляторе.

**Разработка программ для симулятора**
- Подробное изучение работы с симулятором.
- Особенности программирования для симулятора и FPGA.

**Программирование для FPGA**
- Обзор и изучение FPGA модели Tang Nano 1K.
- Разработка программ для Tang Nano.

***


## Основы языка
### Введение
В данном разделе мы рассмотрим базовые конструкции языка SystemVerilog, научимся писать и синтезировать код.

### Инструменты
Для прохождения этого модуля не требуется установка дополнительного программного обеспечения. Код будем писать и синтезировать на платформе [EDA Playground](https://edaplayground.com/home). Для начала работы необходимо создать аккаунт и настроить параметры синтеза:
1. В разделе **Languages & Libraries** найдите поле **Testbench + Design** и выберите **SystemVerilog/Verilog**.
2. В разделе **Tools & Simulators** выберите симулятор в первом поле, установите его значение на **Icarus Verilog**.

### Базовые понятия 
1. **Дизайн** - это описание цифровой схемы или системы, которая выполняет определенную функцию. 
Дизайн включает в себя описание структуры и поведения схемы, используя модули, порты и логические выражения. 

2. **Тестбенч** - это набор инструментов и методов для проверки правильности работы дизайна. 
Тестбенч генерирует тестовые сигналы, подает их на входы модуля и проверяет выходные сигналы на соответствие ожидаемым результатам.

Простыми словами **_Дизайном_** называют код в неком файле .sv в котором нет фунции main,
**_Тестбенчем_** называют тест кейс в который программист тестирует работу дизайна, который в будущем превратиться в схему или систему
 
### Структура программы

**1. Модули**  
Каждая программа в systemVerilog начинается с обьявляение модуля, по своему назначению модуль похож на класс, в других языках программирования. Синткасис модуля следующий:
```verilog
module name_module (

);
 
endmodule
```
**2. Порты**    
После обьявляения модуля, в круглых скобках обьявляются порты. Синтаксис модуля с обьявлением портов:
```verilog
module name_module (
    input int in_value,
    output int out_value
);
 
endmodule
```
Порты работают как функции/методы в других языках программирования
```verilog
 В данном случае, запись:
 input int in_value
 
 Работает так же как и:
 int input(int in_value)
```
Порты бывают трех типов:
- input - Используется для передачи аргументов в модуль, его работу можно сравнить с следующией фунцией:
```cpp
void input(int name) {
    ...
}
```
- output - Используется для возвращения каких либо значений, его работу можно сравнить с следующией фунцией:
```cpp
int output(int name) {
    return name;
}
```
- inout - Порт который обьединяет прием данных и отправку, его работу можно сравнить с следующией фунцией:
```cpp
void modifyData(int &data) {
    ... 
    ...
}
```

### Пример простой программы 
Итак, теперь мы рассмотрим пример простого кода, в котором мы обьявим модуль, порты и 
произведем умножение входного числа на 2.
Для присвоения результата какой либо операции используется ключевое слово **assign**.
```verilog
module module_name (
    input int in_value,  
    output int out_value
);
    assign out_value = in_value * 2;  
endmodule
```
Мы только что создали условный класс **module_name**, где есть 
- Метод приема данных **void in_value(int n)**
- Метод возвращения данных **int out_value()**

Теперь, для тестирования созданного модуля нам нужен **тестбенч**.
Для начала нам нужно создать модуль тестбенча
```verilog
module testbench;
// так как тест бенч не передает и не принимает никаких данных, портов у него не будет.
endmodule
```
Теперь нам необходимо обьявить переменные, и создать обьект модуля **module_name**.
```verilog
    int my_input_value;  
    int my_output_value; 
   
    // Создаем обьект 
    module_name name_object (
        .in_value(my_input_value), // Подключаемся к порту in_value модуя module_name
        .out_value(my_output_value) // Подключаемся к порту in_value модуя module_name
    );
    
```
_Примечание: С точки зрения железа, подключение портов является создаем электрического соединения между сигналами._

Далее, нам нужно обьявить блок **initial**, содержимое этого блока будет выполняться один раз, при старте программы
```verilog
    initial begin
    ...
    end
```

После всего вышеперечисленного, мы можем приступить к реализации основного функционала **тестбенча**. 

Для начала мы передадим в **порт модуля module_name** некое значение, допустим 10.    
После чего, вызовем системную функцию **$display**, которая выведет в консоль значение переменных.  
После вывода данных в консоль нам нужно завершить выполнение программы, при помощи системной функции **$finish**
```verilog
    initial begin
    my_input_value = 10;
    $display("my_input_value=%0d, my_output_value=%0d", my_input_value, my_output_value);
    $finish;
    end
```

**Полный код тестбенча**

```verilog
module testbench;
int my_input_value;  
int my_output_value;

    module_name name (
        .in_value(my_input_value),
        .out_value(my_output_value)
    );

    initial begin

      my_input_value = 10;
      $display("my_input_value=%0d, my_output_value=%0d", my_input_value, my_output_value); 

      $finish;
    end
endmodule
```

### _Задание №0_
Зайдите на платформу [EDA Playground](https://edaplayground.com/home), скопируйте туда этот код и попробуйте скомпилировать.
После чего переработайте программу так, что бы она возводила число в квадрат и выводила в консоль 
```verilog
number squared: squared_numbers
```

### Типы данных

